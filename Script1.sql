/* Индивидуальная работа часть 1
   Мануйлова Е.А. гр. 932121 
   Вариант <3> */

---------------------------------------------------------
-- 1. Создание схемы БД.
/*Ограничения: 1) сумма страхового полиса не может быть отрицательной
2) объём двигателя не может быть отрицательным или больше 10000 литров; 
3) значение поля сумма не может быть отрицательным;
4) значение null допустимо только в поле дата_окончания*/

/*
Добавить: 
- Описание каждого атрибута, обоснование выбора типа данных. Какой тип другой тип данных можно было выбрать.
- Для каждого первичного ключа cказать можно ли было выбрать какой-либо другой атрибут или 
атрибуты в качестве первичного ключа. Появится или какие-либо ограничения на данные если заменить первичный ключ. 
-  Для каждого внешнего ключа добавить описание, причины использования, указать какие ограничения на данные накладывает использование этого внешнего ключа. 
*/
CREATE TABLE IF NOT EXISTS "Владельцы"
(
  "Номер_лицензии" integer NOT NULL,
  "ФИО" text NOT NULL,
  "Адрес" text NOT NULL,
  "Телефон" text NOT NULL,
  CONSTRAINT "PK_Владельцы" PRIMARY KEY ("Номер_лицензии")
);

/*
Атрибуты и их обоснование выбора типа данных:
"Номер_лицензии" (integer, NOT NULL): Этот атрибут выбран типа integer, потому что номер лицензии обычно является целочисленным значением. 
Другой тип данных, который можно было бы использовать, это varchar, если номер лицензии может содержать буквенные символы или специальные 
символы.

"ФИО" (text, NOT NULL): Для ФИО выбран тип данных text, так как он подходит для хранения текстовых значений переменной длины. 
Альтернативным типом данных мог бы быть varchar, но text позволяет хранить более длинные строки.

"Адрес" (text, NOT NULL): Тип данных text выбран для адреса из-за его гибкости в хранении различных форматов адресов. 
Если адрес требует более строгой структуры или валидации, можно было бы использовать отдельные столбцы для города, улицы и номера дома.

"Телефон" (text, NOT NULL): Для телефона также выбран тип данных text, так как номер телефона может содержать различные символы 
(цифры, скобки, знаки тире и т. д.). Другой вариант - использовать varchar с ограничением по длине, если формат телефонного номера стандартизирован.

Первичный ключ выбран как "Номер_лицензии". Другой атрибут, который мог бы быть использован в качестве первичного ключа, - 
это уникальный идентификатор, если таковой имеется в вашей системе и удобен для использования в качестве первичного ключа.
*/

CREATE TABLE IF NOT EXISTS "Страховые_компании"
(
  "ID_Компании" integer NOT NULL,
  "Название" text NOT NULL,
  "Адрес" text NOT NULL,
  "Телефон" text NOT NULL,
  CONSTRAINT "PK_Страховые_компании" PRIMARY KEY ("ID_Компании")
);

/*
Атрибуты и их обоснование выбора типа данных:
"ID_Компании" (integer, NOT NULL): Этот атрибут выбран типа integer, поскольку он представляет собой уникальный числовой идентификатор 
компании. Другой вариант - использовать bigint, если требуется больший диапазон целочисленных значений.

"Название" (text, NOT NULL): Для названия компании использован тип данных text, так как название может быть различной длины. 
Альтернативой может быть varchar с ограничением по длине, если известно максимальное количество символов в названии.

"Адрес" (text, NOT NULL): Тип данных text выбран для адреса компании из-за его гибкости в хранении различных форматов адресов. 
Если адрес требует более строгой структуры или валидации, можно было бы использовать отдельные столбцы для города, улицы и номера дома.

"Телефон" (text, NOT NULL): Для телефона также выбран тип данных text, так как номер телефона может содержать различные символы 
(цифры, скобки, знаки тире и т. д.). Другой вариант - использовать varchar с ограничением по длине, если формат телефонного номера стандартизирован.

Первичный ключ:
Первичный ключ выбран как "ID_Компании". Другой атрибут, который мог бы быть использован в качестве первичного ключа, - 
это уникальный идентификатор, если таковой имеется в вашей системе и удобен для использования в качестве первичного ключа. 
*/

CREATE TABLE IF NOT EXISTS "Автомобили"
(
  "Регистрационный_номер" integer NOT NULL,
  "Номер_лицензии" integer NOT NULL,
  "Марка" text NOT NULL,
  "Цвет" text NOT NULL,
  "Объём_двигателя" DECIMAL NOT NULL,
  "Дата_тех_обслуживания" date NOT NULL,
  "Округ регистрации" text NOT NULL,
  CONSTRAINT "PK_Автомобили" PRIMARY KEY ("Регистрационный_номер"),
  CONSTRAINT "FK_Номер_лицензии" FOREIGN KEY ("Номер_лицензии") REFERENCES "Владельцы"("Номер_лицензии")
);

/*
Атрибуты и их обоснование выбора типа данных:
"Регистрационный_номер" (integer, NOT NULL): Этот атрибут выбран типа integer, так как регистрационный номер обычно является 
целочисленным значением. Другой тип данных, который можно было бы использовать, это varchar, если номер может содержать буквенные 
символы или специальные символы.

"Номер_лицензии" (integer, NOT NULL): Тип данных integer выбран для номера лицензии, предполагая, что он является числовым идентификатором 
владельца. Возможная альтернатива - varchar, если номер может содержать буквенные символы.

"Марка" (text, NOT NULL): Для марки автомобиля выбран тип данных text, так как марка может быть различной длины. Альтернативой может быть 
varchar с ограничением по длине, если известно максимальное количество символов в марке.

"Цвет" (text, NOT NULL): Тип данных text выбран для цвета из-за его гибкости в хранении различных названий цветов. 
Если цвета имеют ограниченный набор значений, можно было бы использовать отдельную таблицу для цветов и использовать внешний ключ.

"Объём_двигателя" (DECIMAL, NOT NULL): DECIMAL выбран для объема двигателя, предполагая, что это числовое значение с десятичной точкой. 
Альтернативой может быть FLOAT или DOUBLE PRECISION в зависимости от требуемой точности.

"Дата_тех_обслуживания" (date, NOT NULL): Для даты технического обслуживания выбран тип данных date, который представляет дату без времени. 
Если требуется точное время, можно использовать тип данных timestamp.

"Округ регистрации" (text, NOT NULL): Тип данных text выбран для округа регистрации из-за его гибкости в хранении различных значений.
 Если округ имеет ограниченный набор значений, можно было бы использовать отдельную таблицу для округов и использовать внешний ключ.

Первичный ключ:
Первичный ключ выбран как "Регистрационный_номер". Другой атрибут, который мог бы быть использован в качестве первичного ключа, - 
это уникальный идентификатор автомобиля, если таковой имеется в вашей системе и удобен для использования в качестве первичного ключа.

Если заменить первичный ключ, могут появиться ограничения на данные:

При использовании другого атрибута в качестве первичного ключа, он должен быть уникальным и не содержать NULL значений.
Изменение первичного ключа может потребовать изменений в запросах или коде, который использует этот ключ для связи с другими таблицами.
Внешний ключ:
Таблица "Автомобили" содержит внешний ключ "Номер_лицензии", который ссылается на таблицу "Владельцы" по атрибуту "Номер_лицензии". 
Причиной использования этого внешнего ключа является установление связи между владельцами и их автомобилями. 
Ограничения на данные, налагаемые внешним ключом, включают:

Обязательность существования соответствующей записи в родительской таблице (в данном случае, "Владельцы").
Автоматическое обновление или удаление связанных записей в зависимости от настроек внешнего ключа (CASCADE, SET NULL и т. д.).
Невозможность добавления записи в дочернюю таблицу со значением внешнего ключа, которого нет в родительской таблице (ограничение на целостность ссылок).
*/

ALTER TABLE "Автомобили" ADD CONSTRAINT "ch_объем_двигателя_диапазон"
CHECK ("Объём_двигателя" >= 0 AND "Объём_двигателя" <= 10000);

CREATE TABLE IF NOT EXISTS "Страховые_полисы"
(
  "Номер_полиса" integer NOT NULL,
  "ID_Компании" integer NOT NULL,
  "Регистрационный_номер" integer NOT NULL,
  "Дата_начала" DATE NOT NULL,
  "Дата_окончания" DATE,
  "Тип_страховки" TEXT NOT NULL,
  "Сумма" DECIMAL NOT NULL,
  CONSTRAINT "FK_ID_Компании" FOREIGN KEY ("ID_Компании") REFERENCES "Страховые_компании"("ID_Компании"),
  CONSTRAINT "FK_Регистрационный_номер" FOREIGN KEY ("Регистрационный_номер") REFERENCES "Автомобили"("Регистрационный_номер")
);

/*
Атрибуты и их обоснование выбора типа данных:
"Номер_полиса" (integer, NOT NULL): Этот атрибут выбран типа integer, так как номер полиса обычно является целочисленным значением. 
Другой тип данных, который можно было бы использовать, это varchar, если номер может содержать буквенные символы или специальные символы.

"ID_Компании" (integer, NOT NULL): Тип данных integer выбран для идентификатора страховой компании, предполагая, что это числовой 
идентификатор компании. Возможная альтернатива - varchar, если ID может содержать буквенные символы.

"Регистрационный_номер" (integer, NOT NULL): Тип данных integer выбран для регистрационного номера автомобиля, так как он обычно 
представляет собой целочисленное значение. Альтернативой может быть varchar, если номер может содержать буквенные символы.

"Дата_начала" (DATE, NOT NULL): Тип данных DATE выбран для даты начала страхования, так как это стандартный формат для хранения даты. 
Другой вариант - TIMESTAMP, если требуется точное время начала страхования.

"Дата_окончания" (DATE): Тип данных DATE выбран для даты окончания страхования, так как это стандартный формат для хранения даты. 
Он может быть NULL, если страховка еще не закончилась.

"Тип_страховки" (TEXT, NOT NULL): Для типа страховки выбран тип данных TEXT, так как тип страховки может быть различным по длине и содержанию. 
Альтернативно можно использовать VARCHAR с ограничением по длине.

"Сумма" (DECIMAL, NOT NULL): DECIMAL выбран для суммы страховки, предполагая, что это числовое значение с десятичной точкой для 
представления денежных сумм.

Первичный ключ:
Первичный ключ выбран как "Номер_полиса". Другой атрибут, который мог бы быть использован в качестве первичного ключа,
 - это уникальный идентификатор полиса, если таковой имеется в вашей системе и удобен для использования в качестве первичного ключа.

Если заменить первичный ключ, могут появиться ограничения на данные:

При использовании другого атрибута в качестве первичного ключа, он должен быть уникальным и не содержать NULL значений.
Изменение первичного ключа может потребовать изменений в запросах или коде, который использует этот ключ для связи с другими таблицами.

Внешние ключи:
"ID_Компании" (FK_ID_Компании): Этот внешний ключ связывает таблицу "Страховые_полисы" с таблицей "Страховые_компании" по ID компании. 
Он используется для установления связи между страховыми полисами и их компаниями. Ограничения на данные, налагаемые этим внешним ключом, 
включают:

Обязательность существования соответствующей записи в родительской таблице (в данном случае, "Страховые_компании").
Автоматическое обновление или удаление связанных записей в зависимости от настроек внешнего ключа (CASCADE, SET NULL и т. д.).
Невозможность добавления записи в дочернюю таблицу со значением внешнего ключа, которого нет в родительской таблице (ограничение на целостность ссылок).
"Регистрационный_номер" (FK_Регистрационный_номер): Этот внешний ключ связывает таблицу "Страховые_полисы" с таблицей "Автомобили" по регистрационному номеру. 
Он используется для установления связи между страховыми полисами и автомобилями. Ограничения на данные, налагаемые этим внешним ключом, включают:

Обязательность существования соответствующей записи в родительской таблице (в данном случае, "Автомобили").
Автоматическое обновление или удаление связанных записей в зависимости от настроек внешнего ключа (CASCADE, SET NULL и т. д.).
Невозможность добавления записи в дочернюю таблицу со значением внешнего ключа, которого нет в родительской таблице (ограничение на целостность ссылок).
*/

ALTER TABLE "Страховые_полисы" ADD CONSTRAINT "ch_сумма_проверка" CHECK ("Сумма" >= 0);

-- 2. Заполнить созданные таблицы данными.

INSERT INTO "Владельцы" ("Номер_лицензии", "ФИО", "Адрес", "Телефон")
VALUES
  (1, 'Иванов Иван Иванович', 'г. Москва, ул. Пушкина, д. 10', '+79101234567'),
  (2, 'Петров Петр Петрович', 'г. Санкт-Петербург, пр. Невский, д. 20', '+79213456789'),
  (3, 'Сидоров Сидор Сидорович', 'г. Екатеринбург, ул. Ленина, д. 30', '+79025687412'),
  (4, 'Алексеев Алексей Алексеевич', 'г. Новосибирск, пр. Октябрьский, д. 40', '+79137894561'),
  (5, 'Кузнецов Кузьма Кузьмич', 'г. Краснодар, ул. Кирова, д. 50', '+79054561278'),
  (6, 'Иванова Елена Ивановна', 'г. Воронеж, пр. Ленина, д. 60', '+79125698745'),
  (7, 'Петрова Ольга Петровна', 'г. Ростов-на-Дону, ул. Советская, д. 70', '+79238745612'),
  (8, 'Сидорова Наталья Сидоровна', 'г. Уфа, ул. Мира, д. 80', '+79015687423'),
  (9, 'Алексеева Анна Алексеевна', 'г. Самара, пр. Кирова, д. 90', '+79124563287'),
  (10, 'Кузнецова Евгения Кузьминична', 'г. Челябинск, ул. Гагарина, д. 100', '+79028561749'),
  (11, 'Иванов Сергей Иванович', 'г. Омск, пр. Ленина, д. 110', '+79105698723'),
  (12, 'Петров Владислав Петрович', 'г. Казань, ул. Пушкина, д. 120', '+79234567891'),
  (13, 'Сидоров Михаил Сидорович', 'г. Владивосток, пр. Светланы, д. 130', '+79047859612'),
  (14, 'Алексеев Никита Алексеевич', 'г. Ярославль, ул. Ленина, д. 140', '+79137894562'),
  (15, 'Кузнецов Юлий Кузьмич', 'г. Иркутск, пр. Октябрьский, д. 150', '+79054561279'),
  (16, 'Иванова Елена Ивановна', 'г. Красноярск, ул. Кирова, д. 160', '+79125698746'),
  (17, 'Петрова Алина Петровна', 'г. Ульяновск, пр. Советская, д. 170', '+79238745613'),
  (18, 'Сидорова Елена Сидоровна', 'г. Тюмень, ул. Мира, д. 180', '+79015687424'),
  (19, 'Алексеева Арина Алексеевна', 'г. Барнаул, пр. Кирова, д. 190', '+79124563288'),
  (20, 'Кузнецова Оксана Кузьминична', 'г. Волгоград, ул. Гагарина, д. 200', '+79028561759'),
  (21, 'Иванов Алексей Иванович', 'г. Саратов, пр. Ленина, д. 210', '+79105698724'),
  (22, 'Петров Константин Петрович', 'г. Тольятти, ул. Пушкина, д. 220', '+79234567892'),
  (23, 'Сидоров Иван Сидорович', 'г. Калининград, пр. Светланы, д. 230', '+79047859613'),
  (24, 'Алексеев Семён Алексеевич', 'г. Оренбург, ул. Ленина, д. 240', '+79137894563'),
  (25, 'Кузнецов Родион Кузьмич', 'г. Томск, пр. Октябрьский, д. 250', '+79054561288'),
  (26, 'Кузнецов Иван Иванович', 'г. Чебоксары, ул. Гагарина, д. 260', '+79016543278'),
  (27, 'Смирнова Екатерина Сергеевна', 'г. Курск, ул. Ленина, д. 270', '+79125698754'),
  (28, 'Михайлов Михаил Михайлович', 'г. Тверь, пр. Октябрьский, д. 280', '+79236587412'),
  (29, 'Васильева Анастасия Ивановна', 'г. Якутск, ул. Пушкина, д. 290', '+79128765432'),
  (30, 'Попов Павел Александрович', 'г. Тула, пр. Советская, д. 300', '+79017894563'),
  (31, 'Соколова Наталья Петровна', 'г. Кемерово, ул. Ленина, д. 310', '+79124568732'),
  (32, 'Лебедев Игорь Владимирович', 'г. Владимир, пр. Гагарина, д. 320', '+79015468723'),
  (33, 'Козлова Елена Алексеевна', 'г. Ярославль, ул. Октябрьская, д. 330', '+79234567893'),
  (34, 'Новиков Никита Сергеевич', 'г. Тамбов, пр. Ленина, д. 340', '+79128765433'),
  (35, 'Морозова Александра Владимировна', 'г. Хабаровск, ул. Гагарина, д. 350', '+79017894564'),
  (36, 'Зайцев Илья Александрович', 'г. Владивосток, пр. Советская, д. 360', '+79124568733'),
  (37, 'Федорова София Викторовна', 'г. Иркутск, ул. Ленина, д. 370', '+79015468724'),
  (38, 'Морозов Даниил Петрович', 'г. Воронеж, пр. Гагарина, д. 380', '+79234567894'),
  (39, 'Полякова Анастасия Владимировна', 'г. Новосибирск, ул. Октябрьская, д. 390', '+79128765434'),
  (40, 'Беляев Степан Владимирович', 'г. Красноярск, пр. Ленина, д. 400', '+79017894565'),
  (41, 'Дмитриева Вера Александровна', 'г. Уфа, ул. Гагарина, д. 410', '+79124568734'),
  (42, 'Богданов Артем Сергеевич', 'г. Самара, пр. Советская, д. 420', '+79015468725'),
  (43, 'Кузнецова Александра Дмитриевна', 'г. Казань, ул. Ленина, д. 430', '+79234567895'),
  (44, 'Ефимов Игорь Артемович', 'г. Нижний Новгород, пр. Октябрьский, д. 440', '+79128765435'),
  (45, 'Жукова Виктория Игоревна', 'г. Омск, ул. Гагарина, д. 450', '+79017894566'),
  (46, 'Григорьев Андрей Алексеевич', 'г. Саратов, пр. Ленина, д. 460', '+79124568735'),
  (47, 'Васильева Вероника Андреевна', 'г. Краснодар, ул. Советская, д. 470', '+79015468726'),
  (48, 'Кузьмина Дарья Александровна', 'г. Челябинск, пр. Гагарина, д. 480', '+79234567896'),
  (49, 'Лаврова Елизавета Сергеевна', 'г. Владивосток, ул. Ленина, д. 490', '+79128765436'),
  (50, 'Панов Владимир Артемович', 'г. Екатеринбург, пр. Октябрьский, д. 500', '+79017894567'),
  (51, 'Денисова Александра Игоревна', 'г. Самара, ул. Гагарина, д. 510', '+79124568736'),
  (52, 'Марков Максим Денисович', 'г. Казань, пр. Ленина, д. 520', '+79234567897'),
  (53, 'Романова Екатерина Максимовна', 'г. Нижний Новгород, ул. Советская, д. 530', '+79128765437'),
  (54, 'Захарова Ольга Дмитриевна', 'г. Омск, пр. Гагарина, д. 540', '+79017894568'),
  (55, 'Белова Марина Викторовна', 'г. Саратов, ул. Ленина, д. 550', '+79124568737');
 

 INSERT INTO "Страховые_компании" ("ID_Компании", "Название", "Адрес", "Телефон")
VALUES
  (1, 'Страховка24', 'г. Москва, ул. Ленина, д. 1', '+79100000001'),
  (2, 'ГарантСтрах', 'г. Санкт-Петербург, пр. Невский, д. 2', '+79100000002'),
  (3, 'АльфаСтрахование', 'г. Екатеринбург, ул. Ленина, д. 3', '+79100000003'),
  (4, 'Согласие', 'г. Новосибирск, ул. Гагарина, д. 4', '+79100000004'),
  (5, 'Росгосстрах', 'г. Казань, ул. Пушкина, д. 5', '+79100000005'),
  (6, 'Ингосстрах', 'г. Самара, ул. Лермонтова, д. 6', '+79100000006'),
  (7, 'Гамма', 'г. Томск, ул. Ленина, д. 7', '+79100000007');



 INSERT INTO "Автомобили" ("Регистрационный_номер", "Номер_лицензии", "Марка", "Цвет", "Объём_двигателя", "Дата_тех_обслуживания", "Округ регистрации")
VALUES
  (1, 1, 'Toyota', 'Синий', 2.5, '2024-01-15', 'Московский'),
  (2, 2, 'BMW', 'Черный', 3.0, '2022-11-20', 'Центральный'),
  (3, 3, 'Ford', 'Красный', 1.8, '2023-03-10', 'Северный'),
  (4, 4, 'Mercedes', 'Серый', 2.0, '2022-09-05', 'Южный'),
  (5, 5, 'Audi', 'Белый', 2.2, '2023-05-28', 'Западный'),
  (6, 6, 'Volkswagen', 'Желтый', 1.6, '2022-12-17', 'Восточный'),
  (7, 7, 'Hyundai', 'Зеленый', 1.5, '2023-02-25', 'Северо-Западный'),
  (8, 8, 'Chevrolet', 'Оранжевый', 2.4, '2022-08-08', 'Юго-Западный'),
  (9, 9, 'Kia', 'Фиолетовый', 1.4, '2023-04-12', 'Северо-Восточный'),
  (10, 10, 'Nissan', 'Серебристый', 2.3, '2022-10-30', 'Юго-Восточный'),
  (11, 11, 'Volvo', 'Бежевый', 2.6, '2023-06-20', 'Центральный'),
  (12, 12, 'Mazda', 'Серебристый', 1.9, '2022-07-14', 'Московский'),
  (13, 13, 'Subaru', 'Фиолетовый', 2.1, '2023-03-05', 'Западный'),
  (14, 14, 'Peugeot', 'Черный', 1.7, '2022-11-28', 'Восточный'),
  (15, 15, 'Renault', 'Серый', 2.2, '2023-01-30', 'Северный'),
  (16, 16, 'Porsche', 'Красный', 3.2, '2022-09-25', 'Южный'),
  (17, 17, 'Ford', 'Синий', 1.6, '2023-05-15', 'Северо-Западный'),
  (18, 18, 'Land Rover', 'Черный', 2.8, '2022-12-10', 'Юго-Западный'),
  (19, 19, 'Ferrari', 'Красный', 4.0, '2022-08-02', 'Северо-Восточный'),
  (20, 20, 'Lamborghini', 'Желтый', 3.5, '2023-04-05', 'Юго-Восточный'),
  (21, 21, 'Bentley', 'Белый', 3.0, '2023-06-25', 'Центральный'),
  (22, 22, 'Bugatti', 'Черный', 5.0, '2022-07-20', 'Московский'),
  (23, 23, 'Aston Martin', 'Серый', 4.5, '2023-03-15', 'Западный'),
  (24, 24, 'McLaren', 'Оранжевый', 3.8, '2022-11-10', 'Восточный'),
  (25, 25, 'Rolls-Royce', 'Черный', 4.2, '2023-01-05', 'Северный'),
  (26, 26, 'Lexus', 'Золотой', 2.8, '2023-02-18', 'Центральный'),
  (27, 27, 'Jaguar', 'Серебристый', 3.5, '2022-10-12', 'Московский'),
  (28, 28, 'Alfa Romeo', 'Красный', 2.0, '2023-04-22', 'Западный'),
  (29, 29, 'Maserati', 'Черный', 3.2, '2022-08-30', 'Северный'),
  (30, 30, 'Lotus', 'Оранжевый', 1.8, '2023-01-10', 'Восточный'),
  (31, 31, 'Infiniti', 'Синий', 2.5, '2022-11-05', 'Северо-Западный'),
  (32, 32, 'Bentley', 'Белый', 4.0, '2023-03-28', 'Юго-Западный'),
  (33, 33, 'Tesla', 'Серый', 2.3, '2022-09-20', 'Северо-Восточный'),
  (34, 34, 'Aston Martin', 'Фиолетовый', 3.8, '2023-05-05', 'Юго-Восточный'),
  (35, 35, 'Porsche', 'Черный', 2.6, '2023-06-15', 'Центральный'),
  (36, 36, 'Ferrari', 'Красный', 4.5, '2022-07-25', 'Московский'),
  (37, 37, 'Lamborghini', 'Желтый', 3.0, '2023-03-18', 'Западный'),
  (38, 38, 'Rolls-Royce', 'Красный', 5.0, '2022-11-15', 'Восточный'),
  (39, 39, 'Bugatti', 'Серебристый', 4.2, '2023-01-28', 'Северный'),
  (40, 40, 'McLaren', 'Оранжевый', 2.1, '2023-05-10', 'Северо-Западный'),
  (41, 41, 'Ford', 'Синий', 3.5, '2022-08-22', 'Юго-Западный'),
  (42, 42, 'Maserati', 'Черный', 2.8, '2023-02-05', 'Северо-Восточный'),
  (43, 43, 'Lotus', 'Белый', 1.9, '2022-10-18', 'Юго-Восточный'),
  (44, 44, 'Infiniti', 'Серый', 2.2, '2023-06-05', 'Центральный'),
  (45, 45, 'Tesla', 'Красный', 2.3, '2022-07-30', 'Московский'),
  (46, 46, 'Aston Martin', 'Фиолетовый', 3.8, '2023-03-20', 'Западный'),
  (47, 47, 'Porsche', 'Черный', 2.6, '2022-11-15', 'Восточный'),
  (48, 48, 'Ferrari', 'Красный', 4.5, '2023-01-25', 'Северный'),
  (49, 49, 'Lamborghini', 'Желтый', 3.0, '2023-05-18', 'Северо-Западный'),
  (50, 50, 'Rolls-Royce', 'Бежевый', 5.0, '2022-08-15', 'Юго-Западный'),
  (51, 51, 'Lexus', 'Золотой', 2.8, '2023-02-18', 'Центральный'),
  (52, 52, 'Jaguar', 'Серебристый', 3.5, '2022-10-12', 'Московский'),
  (53, 53, 'Alfa Romeo', 'Красный', 2.0, '2023-04-22', 'Западный'),
  (54, 54, 'Maserati', 'Черный', 3.2, '2022-08-30', 'Северный'),
  (55, 55, 'Ford', 'Оранжевый', 1.8, '2023-01-10', 'Восточный'),
  (56, 10, 'Toyota', 'Серый', 2.0, '2022-09-10', 'Московский'),
  (57, 15, 'BMW', 'Белый', 3.2, '2023-04-05', 'Центральный'),
  (58, 20, 'Ford', 'Черный', 1.6, '2022-11-15', 'Северный'),
  (59, 25, 'Mercedes', 'Красный', 2.5, '2023-01-25', 'Южный'),
  (60, 30, 'Audi', 'Серебристый', 2.8, '2022-08-20', 'Западный'),
  (61, 35, 'Volkswagen', 'Зеленый', 1.9, '2023-02-15', 'Восточный'),
  (62, 40, 'Hyundai', 'Серый', 2.2, '2022-10-30', 'Северо-Западный'),
  (63, 45, 'Chevrolet', 'Белый', 3.0, '2023-06-10', 'Юго-Западный'),
  (64, 50, 'Ford', 'Черный', 1.7, '2022-07-25', 'Северо-Восточный'),
  (65, 55, 'Nissan', 'Красный', 2.3, '2023-03-20', 'Юго-Восточный'),
  (66, 35, 'Tesla', 'Зеленый', 2.3, '2023-07-30', 'Московский'),
  (67, 1, 'Aston Martin', 'Желтый', 3.8, '2023-04-20', 'Западный'),
  (68, 10, 'Ford', 'Черный', 2.6, '2023-09-15', 'Восточный'),
  (69, 50, 'Ferrari', 'Красный', 4.5, '2023-10-25', 'Северный'),
  (70, 25, 'Lamborghini', 'Желтый', 3.0, '2023-11-10', 'Юго-Западный'),
  (71, 2, 'Rolls-Royce', 'Синий', 5.0, '2023-12-05', 'Северо-Восточный'),
  (72, 3, 'Bugatti', 'Серебристый', 4.2, '2024-01-28', 'Юго-Восточный'),
  (73, 4, 'McLaren', 'Оранжевый', 2.1, '2024-02-10', 'Центральный'),
  (74, 5, 'Ford', 'Синий', 3.5, '2024-03-22', 'Северо-Западный'),
  (75, 6, 'Maserati', 'Черный', 2.8, '2023-04-05', 'Северный'),
  (76, 7, 'Lotus', 'Белый', 1.9, '2023-05-18', 'Юго-Восточный'),
  (77, 10, 'Infiniti', 'Серый', 2.2, '2023-06-05', 'Восточный'),
  (78, 10, 'Toyota', 'Красный', 2.3, '2023-07-30', 'Московский'),
  (79, 20, 'BMW', 'Черный', 3.0, '2022-08-20', 'Западный'),
  (80, 7, 'Ford', 'Серебристый', 1.8, '2023-09-15', 'Северный'),
  (81, 15, 'Mercedes', 'Серый', 2.5, '2023-10-25', 'Южный'),
  (82, 55, 'Audi', 'Белый', 2.8, '2022-11-10', 'Центральный'),
  (83, 6, 'Volkswagen', 'Зеленый', 1.9, '2023-12-05', 'Северо-Восточный'),
  (84, 7, 'Hyundai', 'Серый', 2.2, '2023-01-28', 'Юго-Восточный'),
  (85, 10, 'Chevrolet', 'Белый', 3.0, '2023-02-10', 'Восточный');



INSERT INTO "Страховые_полисы" ("Номер_полиса", "ID_Компании", "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страховки", "Сумма")
VALUES
  (1, 1, 1, '2023-01-01', '2023-01-12', 'КАСКО', 25000.00),
  (2, 1, 1, '2023-02-01', '2023-11-30', 'ОСАГО', 15000.00),
  (3, 1, 2, '2023-05-01', '2024-05-28', 'КАСКО', 30000.00),
  (4, 1, 2, '2023-04-01', '2023-05-31', 'ОСАГО', 20000.00),
  (5, 1, 3, '2023-05-01', '2024-04-12', 'КАСКО', 35000.00),
  (6, 1, 4, '2023-06-01', '2024-06-30', 'ОСАГО', 18000.00),
  (7, 1, 5, '2023-07-01', '2024-07-30', 'КАСКО', 40000.00),
  (8, 1, 5, '2023-08-01', '2024-08-31', 'ОСАГО', 22000.00),
  (9, 1, 6, '2023-09-01', '2023-11-30', 'КАСКО', 28000.00),
  (10, 1, 7, '2023-10-01', '2023-10-09', 'ОСАГО', 25000.00),
  (11, 1, 8, '2023-11-01', '2024-10-31', 'КАСКО', 32000.00),
  (12, 1, 9, '2023-12-01', '2024-12-28', 'ОСАГО', 17000.00),
  (13, 1, 10, '2024-01-01', '2024-12-31', 'КАСКО', 38000.00),
  (14, 1, 10, '2024-02-01', '2024-11-30', 'ОСАГО', 19000.00),
  (15, 1, 10, '2024-03-01', '2025-02-28', 'Страхование от несчастных случаев пассажиров', 42000.00),
  (16, 1, 11, '2023-04-01', '2023-04-11', 'ОСАГО', 23000.00),
  (17, 1, 12, '2024-01-01', '2025-01-05', 'КАСКО', 46000.00),
  (18, 1, 13, '2024-01-01', '2024-09-30', 'ОСАГО', 26000.00),
  (19, 1, 14, '2021-07-01', '2022-11-30', 'КАСКО', 50000.00),
  (20, 1, 15, '2023-08-01', '2024-07-31', 'ОСАГО', 30000.00),
  (21, 2, 16, '2020-09-01', '2021-06-30', 'КАСКО', 55000.00),
  (22, 2, 17, '2024-01-01', '2024-04-09', 'ОСАГО', 32000.00),
  (23, 2, 17, '2024-01-01', '2024-04-09', 'КАСКО', 60000.00),
  (24, 2, 18, '2022-12-01', '2023-02-28', 'ОСАГО', 34000.00),
  (25, 2, 19, '2023-01-01', '2024-12-31', 'КАСКО', 65000.00),
  (26, 2, 19, '2023-02-01', '2024-11-30', 'ОСАГО', 36000.00),
  (27, 2, 20, '2022-03-01', '2022-03-04', 'КАСКО', 70000.00),
  (28, 2, 21, '2024-01-01', '2025-10-31', 'ОСАГО', 38000.00),
  (29, 2, 22, '2022-05-01', '2024-04-30', 'КАСКО', 75000.00),
  (30, 2, 23, '2023-06-01', '2024-09-30', 'ОСАГО', 40000.00),
  (31, 2, 24, '2021-07-01', '2021-07-07', 'КАСКО', 80000.00),
  (32, 2, 25, '2020-08-01', '2021-07-31', 'ОСАГО', 42000.00),
  (33, 2, 26, '2023-09-01', '2024-06-30', 'КАСКО', 85000.00),
  (34, 2, 27, '2023-10-01', '2024-10-31', 'ОСАГО', 44000.00),
  (35, 2, 28, '2023-11-01', '2024-09-30', 'КАСКО', 90000.00),
  (36, 2, 29, '2022-02-01', '2022-02-06', 'ОСАГО', 46000.00),
  (37, 2, 30, '2024-01-01', '2025-12-31', 'КАСКО', 46000.00),
  (38, 2, 30, '2024-02-01', '2025-11-30', 'ОСАГО', 48000.00),
  (39, 2, 31, '2020-03-01', '2020-03-05', 'КАСКО', 95000.00),
  (40, 2, 32, '2023-04-01', '2025-10-31', 'ОСАГО', 50000.00),
  (41, 3, 33, '2023-05-01', '2024-04-10', 'КАСКО', 100000.00),
  (42, 3, 34, '2023-06-01', '2024-09-30', 'ОСАГО', 52000.00),
  (43, 3, 34, '2021-07-01', '2022-11-30', 'КАСКО', 105000.00),
  (44, 3, 35, '2023-08-01', '2023-08-12', 'ОСАГО', 54000.00),
  (45, 3, 36, '2021-09-01', '2022-06-30', 'КАСКО', 110000.00),
  (46, 3, 37, '2023-10-01', '2024-10-31', 'ОСАГО', 56000.00),
  (47, 3, 38, '2023-11-01', '2024-09-30', 'КАСКО', 115000.00),
  (48, 3, 39, '2023-12-01', '2025-02-28', 'ОСАГО', 58000.00),
  (49, 3, 39, '2024-01-01', '2025-12-31', 'КАСКО', 120000.00),
  (50, 3, 40, '2024-02-01', '2026-11-30', 'ОСАГО', 60000.00),
  (51, 3, 41, '2024-04-01', '2024-04-07', 'КАСКО', 125000.00),
  (52, 3, 41, '2024-04-01', '2024-04-07', 'ОСАГО', 62000.00),
  (53, 3, 42, '2023-05-01', '2024-04-30', 'КАСКО', 130000.00),
  (54, 3, 43, '2020-06-01', '2021-09-30', 'ОСАГО', 64000.00),
  (55, 3, 44, '2022-07-01', '2023-04-09', 'КАСКО', 135000.00),
  (56, 3, 45, '2023-08-01', '2024-11-30', 'ОСАГО', 66000.00),
  (57, 3, 46, '2023-09-01', '2024-08-31', 'КАСКО', 140000.00),
  (58, 3, 47, '2023-10-01', '2024-04-02', 'ОСАГО', 68000.00),
  (59, 3, 48, '2023-11-01', '2024-09-30', 'КАСКО', 145000.00),
  (60, 3, 49, '2023-12-01', '2024-02-28', 'ОСАГО', 70000.00),
  (61, 4, 50, '2024-01-01', '2025-12-31', 'КАСКО', 150000.00),
  (62, 4, 51, '2024-02-01', '2025-01-31', 'ОСАГО', 72000.00),
  (63, 4, 51, '2024-03-01', '2025-02-28', 'КАСКО', 155000.00),
  (64, 4, 51, '2023-04-01', '2024-10-31', 'Страхование от несчастных случаев пассажиров', 74000.00),
  (65, 4, 52, '2020-05-01', '2021-04-30', 'КАСКО', 160000.00),
  (66, 4, 53, '2023-06-01', '2024-09-30', 'ОСАГО', 76000.00),
  (67, 4, 54, '2023-07-01', '2024-06-30', 'КАСКО', 165000.00),
  (68, 4, 55, '2023-08-01', '2024-04-03', 'ОСАГО', 78000.00),
  (69, 4, 55, '2023-09-01', '2024-04-03', 'КАСКО', 170000.00),
  (70, 4, 56, '2022-10-01', '2023-10-31', 'ОСАГО', 80000.00),
  (71, 4, 56, '2022-11-01', '2023-09-30', 'КАСКО', 175000.00),
  (72, 4, 57, '2023-12-01', '2024-02-28', 'ОСАГО', 82000.00),
  (73, 4, 58, '2024-01-01', '2024-04-13', 'КАСКО', 180000.00),
  (74, 4, 59, '2024-02-01', '2025-01-31', 'ОСАГО', 82000.00),
  (75, 4, 60, '2024-03-01', '2025-02-28', 'КАСКО', 185000.00),
  (76, 4, 61, '2023-04-01', '2024-10-31', 'ОСАГО', 84000.00),
  (77, 4, 61, '2022-05-01', '2023-04-30', 'КАСКО', 190000.00),
  (78, 4, 62, '2022-06-01', '2023-09-30', 'ОСАГО', 86000.00),
  (79, 4, 63, '2021-07-01', '2022-06-30', 'КАСКО', 195000.00),
  (80, 4, 63, '2023-08-01', '2024-07-31', 'ОСАГО', 88000.00),
  (81, 5, 64, '2024-01-01', '2024-04-06', 'КАСКО', 200000.00),
  (82, 5, 65, '2023-10-01', '2024-10-31', 'ОСАГО', 90000.00),
  (83, 5, 65, '2023-11-01', '2024-09-30', 'КАСКО', 205000.00),
  (84, 5, 65, '2023-12-01', '2024-02-28', 'Страхование от несчастных случаев пассажиров', 92000.00),
  (85, 5, 66, '2024-01-01', '2025-12-31', 'КАСКО', 210000.00),
  (86, 5, 67, '2024-02-01', '2026-01-31', 'ОСАГО', 94000.00),
  (87, 5, 68, '2024-03-01', '2024-04-12', 'КАСКО', 215000.00),
  (88, 5, 69, '2021-04-01', '2022-10-31', 'ОСАГО', 96000.00),
  (89, 5, 70, '2023-05-01', '2024-04-30', 'КАСКО', 220000.00),
  (90, 5, 70, '2023-06-01', '2024-09-30', 'ОСАГО', 98000.00),
  (91, 5, 71, '2023-07-01', '2024-06-30', 'КАСКО', 225000.00),
  (92, 5, 72, '2021-08-01', '2022-07-31', 'ОСАГО', 100000.00),
  (93, 5, 73, '2023-09-01', '2024-08-31', 'КАСКО', 230000.00),
  (94, 5, 74, '2024-01-01', '2024-04-10', 'ОСАГО', 102000.00),
  (95, 5, 75, '2022-11-01', '2024-09-30', 'КАСКО', 235000.00),
  (96, 5, 75, '2020-12-01', '2021-02-28', 'ОСАГО', 104000.00),
  (97, 5, 76, '2024-01-01', '2024-12-31', 'КАСКО', 240000.00),
  (98, 5, 77, '2024-02-01', '2025-01-31', 'ОСАГО', 106000.00),
  (99, 5, 77, '2024-03-01', '2025-02-20', 'КАСКО', 245000.00),
  (100, 5, 78, '2023-04-01', '2024-10-31', 'ОСАГО', 108000.00),
  (101, 6, 79, '2023-02-01', '2024-01-31', 'КАСКО', 30000),
  (102, 6, 79, '2024-03-01', '2025-02-20', 'ДСАГО', 20000),
  (103, 6, 79, '2023-04-01', '2024-03-31', 'Страхование от несчастных случаев пассажиров', 35000),
  (104, 6, 80, '2023-05-01', '2024-04-11', 'ОСАГО', 18000),
  (105, 6, 81, '2023-06-01', '2024-05-31', 'ДСАГО', 22000),
  (106, 6, 81, '2023-07-01', '2024-06-30', 'КАСКО', 40000),
  (107, 6, 82, '2023-08-01', '2024-07-31', 'ОСАГО', 16000),
  (108, 6, 83, '2023-09-01', '2024-08-31', 'ДСАГО', 23000),
  (109, 6, 84, '2023-10-01', '2024-09-30', 'КАСКО', 38000),
  (110, 6, 84, '2023-11-01', '2024-10-31', 'ОСАГО', 17000),
  (111, 6, 85, '2023-12-01', '2023-12-10', 'ДСАГО', 24000);

-- 3. Написать запросы. Устранить дублирование только для тех случаев, где это потенциально возможно.
/*  Добавить: 
- Каждый запрос должен возвращать не менее 5-х строк, если в запросе прямо не указано, что строка может быть только одна.
- Для каждого соединения таблиц развёрнуто описать, зачем оно было добавлено.
-  Для каждого подзапроса развёрнуто описать зачем он был добавлен. Описать что именно возвращает запрос (пример: список верши региона высотой более 1000 м) 
*/

--3.1 Вывести номер лицензии и автомобилей марки “Ford” с объёмом 
--двигателя больше 1.5 литра, страховка которых истекает в ближайшее две недели. Результат упорядочить по объёму двигателя. В выборке должны 
--присутствовать только следующие атрибуты: Номер лицензии, марка автомобиля, объёмом двигателя, число полных дней до окончания страхового 
--периода.
SELECT "Номер_лицензии", "Марка", "Объём_двигателя", DATE_PART('day',(AGE("Дата_окончания", NOW()))) AS Дней_до_окончания
FROM "Автомобили" 
INNER JOIN "Страховые_полисы"
ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер"
WHERE "Марка" = 'Ford' AND "Объём_двигателя" > 1.5 AND DATE_PART('day',(AGE("Дата_окончания", NOW()))) <= 14
ORDER BY "Объём_двигателя";
--повторение идет из-за того, что у автомобиля есть разные типы страхования и оба они заканчиваются
/*
Соединение таблиц:
INNER JOIN "Страховые_полисы" ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер": 
Это соединение таблиц "Автомобили" и "Страховые_полисы" по регистрационному номеру автомобиля. 
Оно было добавлено для связи информации об автомобилях с информацией о страховых полисах, позволяя получить данные об автомобилях, 
которые имеют страховой полис и удовлетворяют заданным условиям.

Запрос возвращает информацию о номере лицензии, марке автомобиля, объеме двигателя и количестве дней до окончания страхового 
полиса для автомобилей марки Ford, с объемом двигателя больше 1.5 и сроком до окончания полиса менее или равным 14 дням.
*/

--3.2. Для каждого владельца найти истёкшие страховки, оформленные на срок менее 2 недель. В выборке должны присутствовать только следующие
--атрибуты: Номер лицензии и ФИО владельца машины, название кампании, количество дней страхования. Результат упорядочить по ФИО.
--Владельцев, у которых нет таких страховок не выводить.

SELECT "Владельцы"."Номер_лицензии", "ФИО", "Название", date_part('day',AGE("Дата_окончания", "Дата_начала")) AS Количество_дней_страхования
FROM "Автомобили"
INNER JOIN "Страховые_полисы"
ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN "Владельцы"
ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
INNER JOIN "Страховые_компании"
ON "Страховые_компании"."ID_Компании" = "Страховые_полисы"."ID_Компании"
WHERE ABS(date_part('day',AGE("Дата_окончания", "Дата_начала"))) <= 14
ORDER BY "ФИО";

/*
Соединение таблиц:
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер": 
Это соединение таблиц "Страховые_полисы" и "Автомобили" по регистрационному номеру автомобиля. 
Оно было добавлено для связи информации о страховых полисах с информацией об автомобилях.

INNER JOIN "Владельцы" ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии": 
Это соединение таблиц "Автомобили" и "Владельцы" по номеру лицензии. 
Оно было добавлено для связи информации об автомобилях с информацией о владельцах.

INNER JOIN "Страховые_компании" ON "Страховые_компании"."ID_Компании" = "Страховые_полисы"."ID_Компании": 
Это соединение таблиц "Страховые_компании" и "Страховые_полисы" по ID компании. 
Оно было добавлено для связи информации о страховых полисах с информацией о страховых компаниях.

Этот запрос возвращает список владельцев автомобилей с их номерами лицензии, ФИО, названием страховой компании и количеством дней страхования, которое не превышает 14 дней.
*/

--3.3. Сформировать статистику по маркам машин. В выборке должны присутствовать следующие атрибуты: марка машины, число машин, средняя
--цена страхового полюса, средний срок страхования в днях для страховок ограниченного срока действия.
SELECT "Марка", COUNT("Марка") AS Число_машин, AVG("Сумма") AS Средняя_цена_страховки,
ROUND(AVG(DATE_PART('year', AGE("Дата_окончания", "Дата_начала")) * 365 + DATE_PART('month', AGE("Дата_окончания", "Дата_начала")) * 30 + DATE_PART('day', AGE("Дата_окончания", "Дата_начала")))::numeric) AS Средний_срок_страхования
FROM "Автомобили"
INNER JOIN "Страховые_полисы"
ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
GROUP BY "Марка";
/*
Соединение таблиц:
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер": 
Это соединение таблиц "Страховые_полисы" и "Автомобили" по регистрационному номеру автомобиля. 
Оно было добавлено для связи информации о страховых полисах с информацией об автомобилях.

Этот запрос возвращает следующую информацию для каждой марки автомобилей:
"Марка": название марки автомобиля.
"Число_машин": количество автомобилей данной марки.
"Средняя_цена_страховки": средняя цена страховки для автомобилей данной марки.
"Средний_срок_страхования": средний срок страхования в днях для автомобилей данной марки.
*/

--ОКРУГЛИТЬ ДО КОПЕЕК
--3.4. Для каждой страховой компании найти среднюю сумма страхования, количество действующих страховок, количество застрахованных
--автомобилей, количество владельцев более чем одной страховки. В расчёт должны быть включены только действующие на данный момент
--страховки (страховок ограниченного срока действия). В выборке должны присутствовать только следующие атрибуты: Название компании, средняя
--сумма страхования, количество действующих страховок, количество застрахованных автомобилей.

SELECT "Страховые_компании"."Название", ROUND(AVG("Сумма"), 2) AS Средняя_сумма_страховки,
COUNT("Страховые_полисы"."Номер_полиса") AS Кол_во_лицензий, 
COUNT(DISTINCT "Страховые_полисы"."Регистрационный_номер") AS Кол_во_застрах_машин,
subquery_two."Количество" AS Владельцы_с_более_одной_страхов
FROM "Страховые_компании"
INNER JOIN "Страховые_полисы"
ON "Страховые_полисы"."ID_Компании" = "Страховые_компании"."ID_Компании"
INNER JOIN 
	(SELECT "ID_Компании",  COUNT(*) AS "Количество"
	FROM ( 
		SELECT "ID_Компании", "Регистрационный_номер"
		FROM "Страховые_полисы"
		WHERE date_part('day', (AGE("Дата_окончания", NOW()))) > 0
		GROUP BY "ID_Компании", "Регистрационный_номер"
		HAVING COUNT(*) > 1
		) AS subquery_one
	GROUP BY "ID_Компании"
	) AS subquery_two
ON "Страховые_компании"."ID_Компании" = subquery_two."ID_Компании"
WHERE date_part('day', (AGE("Дата_окончания", NOW()))) > 0
GROUP BY "Страховые_компании"."ID_Компании", subquery_two."Количество";
/*

Соединение таблиц:
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."ID_Компании" = "Страховые_компании"."ID_Компании": 
Это соединение таблиц "Страховые_полисы" и "Страховые_компании" по идентификатору компании. 
Оно было добавлено для связи информации о страховых полисах с информацией о страховых компаниях.

INNER JOIN subquery_two ON "Страховые_компании"."ID_Компании" = subquery_two."ID_Компании": 
Это соединение таблицы "Страховые_компании" с подзапросом subquery_two по идентификатору компании. 
Оно было добавлено для связи информации о страховых компаниях с результатом подзапроса.

Подзапросы:
subquery_one: Этот подзапрос возвращает идентификатор компании и количество различных регистрационных номеров автомобилей, 
застрахованных у данной компании, у которых срок страхования больше 0 дней. 
Он используется для подсчета количества владельцев с более чем одной страховкой.

subquery_two: Этот подзапрос считает количество компаний, у которых есть владельцы с более чем одной страховкой. 
Он используется для получения информации о количестве владельцев с более чем одной страховкой у каждой компании.
*/



--НАЧЕНИЕ ИСПРАВИТЬ С ЗНАКАМИ В БОЛЬШУЮ ИЛИ МЕНЬШУЮ СТОРОНУ ОТКЛОНЕНИЕ
--3.5. Выбрать действующие страховые полисы, у которых сумма страховки выше средней или ниже средней по марке автомобиля на 15%. В выборке
--должны присутствовать только следующие атрибуты: марка автомобиля, номер страхового полюса, цена страховки, средняя цена страховки по
--марке, отклонение суммы страховки от среднего.

SELECT "Автомобили"."Марка", "Номер_полиса", "Сумма", ROUND("Средняя_цена_марки", 2) AS "Средняя_цена_марки",
ROUND("Сумма" - "Средняя_цена_марки", 2) AS "Отклонение"
FROM "Автомобили"
INNER JOIN "Страховые_полисы"
ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN
    (SELECT "Марка", AVG("Сумма") AS "Средняя_цена_марки"
     FROM "Страховые_полисы"
     INNER JOIN "Автомобили"
     ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер"
     GROUP BY "Марка"
    ) AS subquery_avg
ON "Автомобили"."Марка" = subquery_avg."Марка"
WHERE (date_part('day',(AGE("Дата_окончания", NOW()))) > 0)
AND (("Сумма" > 0.15*"Средняя_цена_марки" + "Средняя_цена_марки") OR ("Сумма" < "Средняя_цена_марки" - 0.15*"Средняя_цена_марки"));

/*
Соединение таблиц:
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер": 
Это соединение таблиц "Страховые_полисы" и "Автомобили" по регистрационному номеру автомобиля. 
Оно было добавлено для связи информации о страховых полисах с информацией об автомобилях.

INNER JOIN subquery_avg ON "Автомобили"."Марка" = subquery_avg."Марка": 
Это соединение таблицы "Автомобили" с подзапросом subquery_avg по марке автомобиля. 
Оно было добавлено для связи информации об автомобилях с результатом подзапроса.

Подзапрос subquery_avg используется для вычисления средней цены страховки для каждой марки автомобилей. 
Он возвращает следующие данные:

"Марка": название марки автомобиля.
"Средняя_цена_марки": средняя цена страховки для автомобилей данной марки.
*/

--3.6. Найти автомобили, на данный момент нигде не застрахованные. В выборке должны присутствовать только следующие атрибуты:
--регистрационный номер автомобиля, ФИО владельца.
SELECT DISTINCT "Страховые_полисы"."Регистрационный_номер", "ФИО"
FROM "Страховые_полисы"
INNER JOIN
(SELECT "Регистрационный_номер", MAX("Дата_окончания") AS max_police
FROM "Страховые_полисы"
GROUP BY "Регистрационный_номер"
) AS subquery_max
ON "Страховые_полисы"."Регистрационный_номер" = subquery_max."Регистрационный_номер"
INNER JOIN "Автомобили"
ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN "Владельцы"
ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
WHERE date_part('day',(AGE("max_police", NOW()))) < 0
ORDER BY "Регистрационный_номер";
/*

Соединение таблиц:
INNER JOIN subquery_max ON "Страховые_полисы"."Регистрационный_номер" = subquery_max."Регистрационный_номер": 
Это соединение таблицы "Страховые_полисы" с подзапросом subquery_max по регистрационному номеру страхового полиса. 
Оно было добавлено для связи информации о страховых полисах с результатом подзапроса.

INNER JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер": 
Это соединение таблиц "Страховые_полисы" и "Автомобили" по регистрационному номеру автомобиля. 
Оно было добавлено для связи информации о страховых полисах с информацией об автомобилях.

INNER JOIN "Владельцы" ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии": 
Это соединение таблицы "Автомобили" с таблицей "Владельцы" по номеру лицензии владельца. 
Оно было добавлено для связи информации об автомобилях с информацией о владельцах.

Подзапрос subquery_max используется для определения последнего действующего страхового полиса для каждого регистрационного номера автомобиля. 
Он возвращает следующие данные:

"Регистрационный_номер": регистрационный номер автомобиля.
"max_police": дата окончания последнего страхового полиса для данного регистрационного номера.
*/


--4. Написать запросы на изменение данных.
/*Добавить: Подробное описание всех действий. */

--4.1. Увеличить страховую сумму в 1,5 раза для автомобилей с объемом двигателя более 2,5 литра
-- SELECT запрос для выборки данных
SELECT
    "Страховые_полисы"."Номер_полиса", -- Выбираем номер страхового полиса
    "Предыдущие_суммы"."Предыдущая_сумма", -- Выбираем сумму предыдущего страхового полиса (из подзапроса "Предыдущие_суммы")
    "Страховые_полисы"."Сумма" * 1.5 AS "Новая_сумма", -- Вычисляем новую сумму страховки, увеличенную на 1,5 от текущей суммы
    "Автомобили"."Объём_двигателя" -- Выбираем объем двигателя автомобиля
FROM "Страховые_полисы"
-- Соединяем таблицу "Страховые_полисы" с таблицей "Автомобили" по регистрационному номеру автомобиля
JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
-- Присоединяем подзапрос "Предыдущие_суммы", который возвращает номер полиса и предыдущую сумму
LEFT JOIN (
    SELECT "Номер_полиса", "Сумма" AS "Предыдущая_сумма" -- Выбираем номер полиса и сумму из "Страховые_полисы"
    FROM "Страховые_полисы"
) AS "Предыдущие_суммы" ON "Страховые_полисы"."Номер_полиса" = "Предыдущие_суммы"."Номер_полиса"
WHERE "Автомобили"."Объём_двигателя" > 2.5 -- Фильтруем по объему двигателя больше 2.5
ORDER BY "Автомобили"."Объём_двигателя" DESC; -- Сортируем по убыванию объема двигателя

-- UPDATE запрос для обновления данных
UPDATE "Страховые_полисы"
SET "Сумма" = "Страховые_полисы"."Сумма" * 1.5 -- Увеличиваем сумму страховки на 1,5
FROM "Автомобили"
WHERE "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер" -- Связываем по регистрационному номеру автомобиля
AND "Автомобили"."Объём_двигателя" > 2.5; -- Фильтруем по объему двигателя больше 2.5

--4.2. Удалить сведения о страховых компаниях, не продавших ни одного страхового полюса.
DELETE FROM "Страховые_компании"
WHERE "ID_Компании" NOT IN (
    SELECT DISTINCT "ID_Компании"
    FROM "Страховые_полисы");
/*Этот запрос удалит все записи из таблицы "Страховые_компании", для которых нет соответствующих записей в таблице "Страховые_полисы", 
то есть компании, которые не продали ни одного страхового полиса.*/

--4.3. Вынести цвета автомобилей в отдельный справочник. 
/*Выделить справочник регионов в отдельную таблицу.*/

CREATE TABLE IF NOT EXISTS "Цвета"
(
  "ID" SERIAL PRIMARY KEY,
  "Название" TEXT NOT NULL
);

--запрос добавляет уникальные цвета из таблицы "Автомобили" в таблицу "Цвета".
INSERT INTO "Цвета" ("Название")
SELECT DISTINCT "Цвет" FROM "Автомобили";

--Добавляет новый столбец "ColorID" в таблицу "Автомобили" для хранения ID цвета.
--INTEGER REFERENCES "Цвета"("ID"): Определяет внешний ключ, связывающий "ColorID" с полем "ID" в таблице "Цвета".
--ON DELETE CASCADE: Указывает, что при удалении записи из таблицы "Цвета" связанные записи в таблице "Автомобили" должны быть также удалены.
ALTER TABLE "Автомобили"
ADD COLUMN "ColorID" INTEGER REFERENCES "Цвета"("ID") ON DELETE CASCADE;

--Обновляет "ColorID" в таблице "Автомобили" на основе соответствия цветов в обеих таблицах.
UPDATE "Автомобили"
SET "ColorID" = "Цвета"."ID"
FROM "Цвета"
WHERE "Автомобили"."Цвет" = "Цвета"."Название";

--Устанавливает ограничение NOT NULL для столбца "ColorID" в таблице "Автомобили", чтобы он не мог содержать пустые значения.
ALTER TABLE "Автомобили" ALTER COLUMN "ColorID" SET NOT NULL;

--Удаляет столбец "Цвет" из таблицы "Автомобили", поскольку теперь цвет хранится в столбце "ColorID".
ALTER TABLE "Автомобили" DROP COLUMN "Цвет";

--Добавляет внешний ключ "FK_Цвета" в таблицу "Автомобили", связывающий "ColorID" с полем "ID" в таблице "Цвета".
ALTER TABLE "Автомобили" ADD CONSTRAINT "FK_Цвета" FOREIGN KEY ("ColorID") REFERENCES "Цвета"("ID");

--ИСПРАВИТЬ
-- 5.1 Создание представления для запроса 3.5
/*
CREATE VIEW Действ_страховые_полисы AS
SELECT "Автомобили"."Марка", "Страховые_полисы"."Номер_полиса", "Страховые_полисы"."Сумма", subquery_avg."Средняя_цена_марки",
ABS("Страховые_полисы"."Сумма" - subquery_avg."Средняя_цена_марки") AS Отклонение
FROM "Автомобили"
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN (
SELECT "Марка", AVG("Сумма") AS "Средняя_цена_марки"
FROM "Страховые_полисы"
INNER JOIN "Автомобили" ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер"
GROUP BY "Марка"
) AS subquery_avg ON "Автомобили"."Марка" = subquery_avg."Марка"
WHERE (date_part('day',(AGE("Дата_окончания", NOW()))) > 0)
AND (("Страховые_полисы"."Сумма" > 0.15 * subquery_avg."Средняя_цена_марки" + subquery_avg."Средняя_цена_марки") OR
("Страховые_полисы"."Сумма" < subquery_avg."Средняя_цена_марки" - 0.15 * subquery_avg."Средняя_цена_марки"));
*/

CREATE VIEW Действ_страховые_полисы AS
SELECT "Автомобили"."Марка", "Страховые_полисы"."Номер_полиса", "Страховые_полисы"."Сумма", ROUND(subquery_avg."Средняя_цена_марки", 2) AS "Средняя_цена_марки",
ROUND("Страховые_полисы"."Сумма" - subquery_avg."Средняя_цена_марки", 2) AS "Отклонение"
FROM "Автомобили"
INNER JOIN "Страховые_полисы" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN (
    SELECT "Марка", AVG("Сумма") AS "Средняя_цена_марки"
    FROM "Страховые_полисы"
    INNER JOIN "Автомобили" ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер"
    GROUP BY "Марка"
) AS subquery_avg ON "Автомобили"."Марка" = subquery_avg."Марка"
WHERE (date_part('day',(AGE("Дата_окончания", NOW()))) > 0)
AND (("Страховые_полисы"."Сумма" > 0.15 * subquery_avg."Средняя_цена_марки" + subquery_avg."Средняя_цена_марки") OR
("Страховые_полисы"."Сумма" < subquery_avg."Средняя_цена_марки" - 0.15 * subquery_avg."Средняя_цена_марки"));

SELECT * FROM Действ_страховые_полисы;

-- 5.1 Создание представления для запроса 3.6
CREATE VIEW Незастрахованные_автомобили AS
SELECT DISTINCT "Страховые_полисы"."Регистрационный_номер", "Владельцы"."ФИО"
FROM "Страховые_полисы"
INNER JOIN (
SELECT "Регистрационный_номер", MAX("Дата_окончания") AS max_police
FROM "Страховые_полисы"
GROUP BY "Регистрационный_номер"
) AS subquery_max ON "Страховые_полисы"."Регистрационный_номер" = subquery_max."Регистрационный_номер"
INNER JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN "Владельцы" ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
WHERE date_part('day',(AGE("max_police", NOW()))) < 0
ORDER BY "Страховые_полисы"."Регистрационный_номер";

SELECT * FROM Незастрахованные_автомобили;

-- 5.2 Создание представления для запроса 5.2
CREATE VIEW Застрахованные_автомобили AS
SELECT "Владельцы"."Номер_лицензии", "Владельцы"."ФИО", "Владельцы"."Телефон", "Автомобили"."Марка",
ROUND(DATE_PART('year', AGE(NOW(), "Дата_начала")) * 365 + DATE_PART('month', AGE(NOW(), "Дата_начала")) * 30 + DATE_PART('day', AGE(NOW(), "Дата_начала"))::numeric) AS "Дней_с_техосмотра",
"Страховые_полисы"."Номер_полиса", "Страховые_полисы"."Тип_страховки", "Страховые_полисы"."Сумма"
FROM "Страховые_полисы"
INNER JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
INNER JOIN "Владельцы" ON "Автомобили"."Номер_лицензии" = "Владельцы"."Номер_лицензии"
WHERE date_part('day',(AGE("Дата_окончания", NOW()))) > 0;

SELECT * FROM Застрахованные_автомобили;

--6. Написать процедуры и функции, согласно условиям. Все процедуры и функции при необходимости должны включать обработчики исключений. 
--Названия функций: F_<имя>. Формат названий процедур: P_<имя>. Написать анонимные блоки или запросы для проверки работы процедур и 
--функций. 
--6.1. Написать функцию, которая для заданной страховой компании возвращает количество автовладельцев, имеющих действующие полисы 
--(id_компании и промежуток времени – аргументы функции). Если промежуток времени не указан, считается количество за всё время.

CREATE OR REPLACE FUNCTION F_count_policy_holders(p_id_company INTEGER, p_start_date DATE = NULL, p_end_date DATE = NULL)
RETURNS INTEGER AS $$
DECLARE
v_count INTEGER;
BEGIN
IF p_start_date IS NULL OR p_end_date IS NULL THEN
SELECT COUNT(DISTINCT "Номер_лицензии")
INTO v_count
FROM "Страховые_полисы"
JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
WHERE "Страховые_полисы"."ID_Компании" = p_id_company;
ELSE
SELECT COUNT(DISTINCT "Номер_лицензии")
INTO v_count
FROM "Страховые_полисы"
JOIN "Автомобили" ON "Страховые_полисы"."Регистрационный_номер" = "Автомобили"."Регистрационный_номер"
WHERE "Страховые_полисы"."ID_Компании" = p_id_company AND "Страховые_полисы"."Дата_начала" >= p_start_date AND ("Страховые_полисы"."Дата_окончания" <= p_end_date OR "Страховые_полисы"."Дата_окончания" IS NULL);
END IF;
RETURN v_count;
EXCEPTION
WHEN OTHERS THEN
RAISE EXCEPTION 'Ошибка при выполнении функции F_count_policy_holders: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

--анонимный блок для проверки работы этой функции
DO $$
DECLARE
v_count INTEGER;
BEGIN
v_count := F_count_policy_holders(1, '2024-01-01', '2024-12-31');
RAISE NOTICE 'Количество автовладельцев с действующими полисами: %', v_count;
EXCEPTION
WHEN OTHERS THEN
RAISE EXCEPTION 'Ошибка при выполнении анонимного блока: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

--6.2. Написать функцию, которая для каждой страховой компании возвращает среднюю длительность страхового периода в днях. Значение может 
--рассчитываться за конкретный период и/или для конкретной марки автомобиля. Принадлежность страхового периода указному временному 
--промежутку определяется по дате начала, бессрочные полисы в расчете не учитываются. Функция имеет три аргумента: id_копании, начало 
--периода (с точностью до дня), окончание периода (с точность до дня). Только первый аргумент является обязательным. Предусмотреть вариант 
--вызова функции без необязательных аргументов.

CREATE OR REPLACE FUNCTION F_avg_insurance_duration(p_id_company INTEGER, p_start_date DATE = NULL, p_end_date DATE = NULL)
RETURNS DECIMAL AS $$
DECLARE
v_avg_duration DECIMAL;
BEGIN
IF p_start_date IS NULL OR p_end_date IS NULL THEN
SELECT AVG("Дата_окончания" - "Дата_начала")
INTO v_avg_duration
FROM "Страховые_полисы"
WHERE "ID_Компании" = p_id_company AND "Дата_окончания" IS NOT NULL;
ELSE
SELECT AVG("Дата_окончания" - "Дата_начала")
INTO v_avg_duration
FROM "Страховые_полисы"
WHERE "ID_Компании" = p_id_company AND "Дата_начала" >= p_start_date AND "Дата_окончания" <= p_end_date;
END IF;
RETURN ROUND(v_avg_duration::NUMERIC, 0);
EXCEPTION
WHEN OTHERS THEN
RAISE EXCEPTION 'Ошибка при выполнении функции F_avg_insurance_duration: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
--анонимный блок для проверки работы этой функции
DO $$
DECLARE
v_avg_duration DECIMAL;
BEGIN
v_avg_duration := F_avg_insurance_duration(1, '2024-01-01', '2024-12-31');
RAISE NOTICE 'Средняя длительность страхового периода в днях: %', v_avg_duration;
EXCEPTION
WHEN OTHERS THEN
RAISE EXCEPTION 'Ошибка при выполнении анонимного блока: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

--6.3. Написать процедуру, которая формирует список автомобилистов с истёкшим сроком страхования в заданном округе регистрации (округ 
--регистрации – аргумент процедуры). Обратите внимание, что на автомобиль может быть оформлено несколько полисов. Формат вывода: 
--------------------------------------------------------
--Список автовладельцев для проверки на <число>:
--1. <ФИО автовладельца 1>. Полис <номер полиса> на <марка> рег. номер <регистрационный номер> просрочен на <число> дня.
--<и т. д.> …. 
--------------------------------------------------------

DROP PROCEDURE IF EXISTS P_expired_insurance(p_district VARCHAR);

-- Create the procedure
CREATE OR REPLACE PROCEDURE P_expired_insurance(p_district VARCHAR)
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN
        SELECT "Владельцы"."ФИО", "Страховые_полисы"."Номер_полиса", "Автомобили"."Марка", "Автомобили"."Регистрационный_номер", CURRENT_DATE - "Страховые_полисы"."Дата_окончания" AS "Days_Expired"
        FROM "Владельцы"
        JOIN "Автомобили" ON "Владельцы"."Номер_лицензии" = "Автомобили"."Номер_лицензии"
        JOIN "Страховые_полисы" ON "Автомобили"."Регистрационный_номер" = "Страховые_полисы"."Регистрационный_номер"
        WHERE "Автомобили"."Округ регистрации" = p_district AND "Страховые_полисы"."Дата_окончания" < CURRENT_DATE
    LOOP
        RAISE NOTICE '%. Полис % на % рег. номер % просрочен на % дня.', rec."ФИО", rec."Номер_полиса", rec."Марка", rec."Регистрационный_номер", rec."Days_Expired";
    END LOOP;
END; 
$$;

-- Call the procedure
CALL P_expired_insurance('Московский');



--6.4. Написать процедуру, которая выполняете копирование всех данных об указанной страховой компании, включая страховые полисы. Аргумент
--процедуры - id_компании. Для скопированной записи ставится отметка “копия” в поле название.

CREATE OR REPLACE PROCEDURE P_CopyInsuranceCompanyData
    (id_компании INTEGER)
AS
$$
DECLARE
    новый_id_компании INTEGER;
BEGIN
    BEGIN
        -- Проверяем, существует ли компания с указанным ID
        IF NOT EXISTS (SELECT 1 FROM "Страховые_компании" WHERE "ID_Компании" = id_компании) THEN
            RAISE NOTICE 'Указан неверный ID страховой компании';
            RETURN;
        END IF;

        -- Генерируем новый ID для копии компании
        SELECT MAX("ID_Компании") + 1 INTO новый_id_компании FROM "Страховые_компании";

        -- Копируем данные о страховой компании
        INSERT INTO "Страховые_компании" ("ID_Компании", "Название", "Адрес", "Телефон")
        SELECT новый_id_компании, CONCAT("Название", ' (копия)'), "Адрес", "Телефон"
        FROM "Страховые_компании"
        WHERE "ID_Компании" = id_компании;

        -- Копируем данные о страховых полисах
        INSERT INTO "Страховые_полисы" ("Номер_полиса", "ID_Компании", "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страховки", "Сумма")
        SELECT "Номер_полиса", новый_id_компании, "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страховки", "Сумма"
        FROM "Страховые_полисы"
        WHERE "ID_Компании" = id_компании;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Ошибка при копировании данных: %', SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;

--копируем
CALL P_CopyInsuranceCompanyData(5);
--проверка
SELECT *
FROM "Страховые_компании"


--7. Создать триггеры, включить обработчики исключений. Написать скрипты для проверки. При необходимости снять ограничения (если 
--ограничение мешает проверить работу триггера).
--7.1. Написать триггер, активизирующийся при изменении содержимого таблицы «Страховые_полисы» и проверяющий, чтобы дата начала была 
--меньше даты окончания и поле «сумма» заполнялось автоматически в зависимости от типа страхования и объема двигателя, в соответствии с 
--таблицей (таблицу задать самостоятельно).
DROP TABLE IF EXISTS "Тарифы";

--— Создание таблицы тарифов
CREATE TABLE IF NOT EXISTS "Тарифы"
(
"Тип_страховки" TEXT NOT NULL,
"Мин_объем_двигателя" DECIMAL NOT NULL,
"Макс_объем_двигателя" DECIMAL NOT NULL,
"Сумма" DECIMAL NOT NULL,
CONSTRAINT "PK_Тарифы" PRIMARY KEY ("Тип_страховки", "Мин_объем_двигателя", "Макс_объем_двигателя")
);

--— Вставка данных в таблицу тарифов
INSERT INTO "Тарифы" ("Тип_страховки", "Мин_объем_двигателя", "Макс_объем_двигателя", "Сумма")
VALUES ('КАСКО', 0, 1.6, 50000),
('КАСКО', 1.6, 5, 75000),
('КАСКО', 2.5, 10000, 100000),
('ОСАГО', 0, 1.6, 10000),
('ОСАГО', 1.6, 5, 15000),
('ОСАГО', 2.5, 10000, 20000),
('ДСАГО', 0, 1.6, 12000),
('ДСАГО', 1.6, 5, 18000),
('ДСАГО', 2.5, 10000, 24000),
('Страхование от несчастных случаев пассажиров', 0, 10000, 5000);

--— Удалим предыдущий триггер, если он существует
DROP TRIGGER IF EXISTS check_and_update_insurance_policy_trigger ON "Страховые_полисы";

--— Создание триггера на таблице "Страховые_полисы"
CREATE OR REPLACE FUNCTION check_and_update_insurance_policy()
RETURNS TRIGGER AS $$
DECLARE
volume DECIMAL;
BEGIN
--— Проверка даты начала и окончания страхования
IF NEW."Дата_начала" >= NEW."Дата_окончания" THEN
RAISE EXCEPTION 'Дата начала страхования должна быть меньше даты окончания!';
END IF;

--— Получение объема двигателя из таблицы "Автомобили"
SELECT "Объём_двигателя" INTO volume
FROM "Автомобили"
WHERE "Регистрационный_номер" = NEW."Регистрационный_номер";

--— Расчет суммы в зависимости от типа страховки и объема двигателя
SELECT "Сумма" INTO NEW."Сумма"
FROM "Тарифы"
WHERE "Тип_страховки" = NEW."Тип_страховки"
AND volume BETWEEN "Мин_объем_двигателя" AND "Макс_объем_двигателя";

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--— Привязываем триггер к таблице "Страховые_полисы"
CREATE TRIGGER check_and_update_insurance_policy_trigger
BEFORE INSERT OR UPDATE ON "Страховые_полисы"
FOR EACH ROW
EXECUTE FUNCTION check_and_update_insurance_policy();

--— Вставка данных о страховом полисе
INSERT INTO "Страховые_полисы" ("Номер_полиса", "ID_Компании", "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страховки")
VALUES (10000, 1, 1, '2024-04-01', '2025-04-01', 'КАСКО');
--— Проверка, что данные были успешно добавлены
SELECT * FROM "Страховые_полисы" WHERE "Номер_полиса" = 10000;

UPDATE "Страховые_полисы"
SET "Дата_окончания" = '2026-04-01'
WHERE "Номер_полиса" = 10000;
--— Проверка отсутствия изменений данных
SELECT * FROM "Страховые_полисы" WHERE "Номер_полиса" = 10000;

DELETE FROM "Страховые_полисы"
WHERE "Номер_полиса" = 10000;
--— Проверка отсутствия удаленных данных
SELECT * FROM "Страховые_полисы" WHERE "Номер_полиса" = 10000;

--— Попытка вставить полис с неправильной датой начала
INSERT INTO "Страховые_полисы" ("Номер_полиса", "ID_Компании", "Регистрационный_номер", "Дата_начала", "Дата_окончания", "Тип_страховки")
VALUES (20000, 1, 123456, '2024-04-02', '2024-04-01', 'ОСАГО');

--— Проверка отсутствия добавленных данных
SELECT * FROM "Страховые_полисы" WHERE "Номер_полиса" = 20000;

--7.2 Написать триггер, сохраняющий статистику изменений таблицы «Автомобили» в таблице «Авто_Статистика», в которой хранится дата 
--изменения, тип изменения (insert, update, delete). Триггер также выводит на экран сообщение с указанием количества дней прошедших со дня 
--последнего изменения.

CREATE TABLE IF NOT EXISTS "Авто_Статистика"
(
"ID" SERIAL PRIMARY KEY,
"Дата_изменения" DATE NOT NULL,
"Тип_изменения" TEXT NOT NULL
);

-- Создание триггера на таблице "Автомобили"
CREATE OR REPLACE FUNCTION update_auto_statistic()
RETURNS TRIGGER AS $$
DECLARE
last_change_date DATE;
days_since_last_change INTEGER;
BEGIN
-- Получаем дату последнего изменения в таблице "Авто_Статистика"
SELECT MAX("Дата_изменения") INTO last_change_date FROM "Авто_Статистика";

-- Рассчитываем количество дней, прошедших со дня последнего изменения
days_since_last_change := (SELECT CURRENT_DATE - last_change_date);

-- Вставляем запись о текущем изменении в таблицу "Авто_Статистика"
INSERT INTO "Авто_Статистика" ("Дата_изменения", "Тип_изменения")
VALUES (CURRENT_DATE, TG_OP);

-- Выводим сообщение с указанием количества дней, прошедших с последнего изменения
RAISE NOTICE 'Дней с последнего изменения: %', days_since_last_change;

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Привязываем триггер к таблице "Автомобили"
CREATE TRIGGER auto_changes_trigger
AFTER INSERT OR UPDATE OR DELETE ON "Автомобили"
FOR EACH ROW
EXECUTE FUNCTION update_auto_statistic();

-- Вставка новой записи в таблицу "Автомобили"
INSERT INTO "Автомобили" ("Регистрационный_номер", "Номер_лицензии", "Марка", "Цвет", "Объём_двигателя", "Дата_тех_обслуживания", "Округ регистрации")
VALUES (123456, 1, 'Toyota', 'Синий', 2.0, '2024-04-01', 'Москва');
-- Проверка добавления данных
SELECT * FROM "Автомобили" WHERE "Регистрационный_номер" = 123456;

-- Обновление существующей записи в таблице "Автомобили"
UPDATE "Автомобили"
SET "Марка" = 'Honda'
WHERE "Регистрационный_номер" = 123456;
-- Проверка изменения данных
SELECT * FROM "Автомобили" WHERE "Регистрационный_номер" = 123456 AND "Марка" = 'Honda';
--Проверка отсутствия изменений данных
SELECT * FROM "Автомобили" WHERE "Регистрационный_номер" = 123456 AND "Марка" = 'Toyota';

-- Удаление записи из таблицы "Автомобили"
DELETE FROM "Автомобили"
WHERE "Регистрационный_номер" = 123456;
-- Проверка удаления данных
SELECT * FROM "Автомобили" WHERE "Регистрационный_номер" = 123456;

--7.3 Написать триггер, активизирующийся при вставке в таблицу “Страховые компании” и проверяющий наличие компании с указанным 
--наименованием. Если такая компания уже существует, вместо вставки обновляются значения полей адрес и телефон.

CREATE OR REPLACE FUNCTION check_and_update_insurance_company()
RETURNS TRIGGER AS $$
BEGIN
--Проверка наличия компании с указанным наименованием
IF EXISTS (SELECT 1 FROM "Страховые_компании" WHERE "Название" = NEW."Название") THEN
-- Обновление значений полей адреса и телефона
UPDATE "Страховые_компании"
SET "Адрес" = NEW."Адрес",
"Телефон" = NEW."Телефон"
WHERE "Название" = NEW."Название";

-- Отмена вставки новой записи
RETURN NULL;
ELSE
-- Продолжение вставки новой записи
RETURN NEW;
END IF;
END;
$$ LANGUAGE plpgsql;

--— Привязываем триггер к таблице "Страховые компании"
CREATE TRIGGER check_and_update_insurance_company_trigger
BEFORE INSERT ON "Страховые_компании"
FOR EACH ROW
EXECUTE FUNCTION check_and_update_insurance_company();

--— Вставка новой компании в таблицу "Страховые компании"
INSERT INTO "Страховые_компании" ("ID_Компании", "Название", "Адрес", "Телефон")
VALUES (8, 'Новая страховая компания', 'Улица Пушкина, дом Колотушкина', '+79132877291');
--— Проверка отсутствия добавленных данных
SELECT * FROM "Страховые_компании" WHERE "Название" = 'Новая страховая компания';

--— Изменение адреса и телефона компании в таблице "Страховые компании"
UPDATE "Страховые_компании"
SET "Адрес" = 'Новый адрес', "Телефон" = '+79200745600'
WHERE "Название" = 'Новая страховая компания';
--Проверка отсутствия изменений данных
SELECT * FROM "Страховые_компании" WHERE "Название" = 'Новая страховая компания';

--— Удаление компании из таблицы "Страховые компании"
DELETE FROM "Страховые_компании"
WHERE "Название" = 'Новая страховая компания';
--— Проверка отсутствия удаленных данных
SELECT * FROM "Страховые_компании" WHERE "Название" = 'Новая страховая компания';

--— Попытка вставить компанию с уже существующим наименованием в таблицу "Страховые компании"
INSERT INTO "Страховые_компании" ("ID_Компании", "Название", "Адрес", "Телефон")
VALUES (9, 'Ингосстрах', 'Новый адрес', '+79132877291');

--— Проверка отсутствия добавленных данных
SELECT * FROM "Страховые_компании" WHERE "Название" = 'Ингосстрах';


